import Stats_Functions as stat
import numpy as np
import matplotlib.pyplot as plt
import math
import pandas as pd

energyDf = pd.read_csv("C:/Users/ucg8nb/Downloads/Green_Electricity_Data.csv")
energyDf = energyDf.drop(index = [4, 30, 46, 18])

prices = energyDf['Average Electricity Price'].to_list()
percSolWind = energyDf['Percent Solar and Wind'].to_list()

#pd.DataFrame({prices[0]:prices[1:]}).set_index(prices[0]).to_csv(stat.getDownloadsTab() + '/prices.csv')
#pd.DataFrame({percSolWind[0]:percSolWind[1:]}).set_index(percSolWind[0]).to_csv(stat.getDownloadsTab() + '/percSolWind.csv')

pricePlotPos = stat.metaGaussianPlottingPositions(len(prices))
'''plt.scatter(x = sorted(prices), y = pricePlotPos, color = 'gray')
plt.title('Empirical Distribution of prices')
plt.xlabel('Price of electricity')
plt.ylabel('Cumulative probability density')
plt.savefig(stat.getDownloadsTab() + '/Empirical distribution prices.png')'''

nums = np.arange(0,45, 0.01)
gumbel = stat.gumbelDF(nums, 8.0687, 13.2906)
normal = stat.normalDF(nums, 17.3734 , 9.9647)

# plt.scatter(x = nums, y = gumbel, color = 'gray', label = 'Gumbel')
# plt.scatter(x = sorted(prices), y = pricePlotPos, color = 'lightgray', label = 'Empirical Distribution')
# plt.title('Estimated Gumbel Distribution')
# plt.xlabel('Price of Electricity')
# plt.ylabel('Cumulative Probability Density')
# plt.legend()
# plt.savefig(stat.getDownloadsTab() + '/Gumbel Distribution Function.png')
# plt.clf()
#
# plt.scatter(x = nums, y = normal, color = 'gray', label = 'Normal')
# plt.scatter(x = sorted(prices), y = pricePlotPos, color = 'lightgray', label = 'Empirical Distribution')
# plt.title('Estimated Normal Distribution')
# plt.xlabel('Price of Electricity')
# plt.ylabel('Cumulative Probability Density')
# plt.legend()
# plt.savefig(stat.getDownloadsTab() + '/Normal Distribution Function.png')
# plt.clf()

percPlotPos = stat.metaGaussianPlottingPositions(len(percSolWind))
# plt.scatter(x = sorted(percSolWind), y = percPlotPos, color = 'gray')
# plt.title('Empirical Distribution of Percentage Solar and Wind')
# plt.xlabel('Percentage of Power Generated by Solar/Wind')
# plt.ylabel('Cumulative Probability Density')
# plt.savefig(stat.getDownloadsTab() + '/Empirical Dist perc sol-wind without outlier.png')

# dists = ['NM', 'GB', 'LG', 'RG', 'LP']
# nums = np.arange(0, 50, 0.01)
# plt.scatter(x = sorted(percSolWind), y = percPlotPos, color = 'gray', label = 'Empirical distribution')
# shades = [str(i/8) for i in range(2,7)]
# for i in range(len(dists)):
#     d = dists[i]
#     col = shades[i]
#     alpha, beta = stat.fitRegressUnbounded(d, percSolWind)
#     plt.scatter(s = 1,x = nums, color = col, y = stat.getUnboundedDF(d, alpha, beta, nums), label = d)
# plt.legend()
# plt.show()

# nums = np.arange(0, 50, 0.01)
# plt.scatter(x = sorted(percSolWind), y = percPlotPos, color = 'gray', label = 'Empirical distribution')
# alpha, beta = stat.fitRegressUnbounded("NM", percSolWind)
# plt.scatter(s = 10, x = nums, y = stat.getUnboundedDF('NM', alpha, beta, nums), label = 'NM', color = 'lightgray')
# plt.title('Fitted Normal distribution')
# plt.xlabel('Percentage electricity produced by solar and wind')
# plt.ylabel('Cumulative probability density')
# plt.legend()
# plt.savefig(stat.getDownloadsTab() + '/NM Fitted Perc Sol Wind.png')

# dists = ['WB', 'IW', 'LW', 'LL']
# nums = np.arange(0.01, 50, 0.01)
# #plt.scatter(x = sorted(percSolWind), y = percPlotPos, color = 'gray', label = 'Empirical distribution')
# #shades = [str(i/8) for i in range(2,7)]
# outputDf = pd.DataFrame()
# for i in range(len(dists)):
#     d = dists[i]
#     #col = shades[i]
#     alpha, beta = stat.fitRegressBounded(d, percSolWind, 0)
#     result = stat.getBoundedDF(d, nums, alpha, beta, 0)
#     estimates = stat.getBoundedDF(d, np.array(sorted(percSolWind)), alpha, beta, 0)
#     notUseful, extraNotUseful, KStestStat = stat.calcKStest(estimates)
#     newRow = {
#         'Distribution': d,
#         'Alpha': alpha,
#         'Beta': beta,
#         'Result': result,
#         'KS Test Stat': KStestStat,
#         'Significance': stat.getKSTestSig(KStestStat, len(percSolWind))
#     }
#     outputDf = outputDf._append(newRow, ignore_index = True)
#     #plt.scatter(s = 1,x = nums, color = col, y = stat.getBoundedDF(d, nums, alpha, beta,0), label = d)
# #plt.legend()
# #plt.show()
# print(outputDf[['Distribution', 'Alpha', 'Beta', 'KS Test Stat', 'Significance']])
#
# nums = np.arange(0.01, 50, 0.01)
# plt.scatter(x = sorted(percSolWind), y = percPlotPos, color = 'gray', label = 'Empirical distribution')
# alphaWB, betaWB = stat.fitRegressBounded("WB", percSolWind, 0)
# wbDF = stat.getBoundedDF('WB', nums, alphaWB, betaWB, 0)
# plt.scatter(x = nums, y = wbDF, color = 'lightgray', label = 'WB', s = 10)
# alphaLL, betaLL = stat.fitRegressBounded('LL', percSolWind, 0)
# llDF = stat.getBoundedDF("LL", nums, alphaLL, betaLL, 0)
# plt.scatter(x = nums, y = llDF, color = 'darkgray', label = "LL", s = 10)
# plt.legend()
# plt.title("Fitted Weibull and Log-Logistic distributions")
# plt.ylabel('Cumulative probability density')
# plt.xlabel('Percentage of electricity produced by wind and solar')
# plt.savefig(stat.getDownloadsTab() + '/Weibull vs Log-Logistic sol-wind.png')

alphaPrice = 8.0687
betaPrice = 13.2906
alphaPerc = 12.1378
betaPerc = 0.9138

empNQTPrice = stat.empiricalNQT(prices)
empNQTPerc = stat.empiricalNQT(percSolWind)

gamma = stat.getCorrelation(empNQTPrice, empNQTPerc)

nums = np.arange(0, 50, 0.01)
priorPrice = stat.gumbeldf(nums, alphaPrice, betaPrice)

def h(x,y, gamma):
    nqtX = stat.inverseStandardNormal(stat.weibullDF(x, alphaPerc, betaPerc, 0))
    nqtY = stat.inverseStandardNormal(stat.gumbelDF(y, alphaPrice, betaPrice))

    xi = (1 / (np.sqrt(1 - gamma * gamma))) * np.exp( ((-1 * gamma) / (2 * ( 1 - gamma * gamma))) * (gamma * nqtX * nqtX - 2 * nqtX * nqtY + gamma * nqtY * nqtY))
    fx = stat.weibulldf(x, alphaPerc, betaPerc, 0)
    fy = stat.gumbeldf(y, alphaPrice, betaPrice)

    return xi * fx * fy

def kx(x, nums):
    sum = 0
    for n in nums.tolist():
        fy = stat.gumbeldf(n, alphaPrice, betaPrice)
        fx = h(x, n, gamma)
        sum += fy * fx * 0.01
    return sum

def phi(nums, x):
    k = kx(x, nums)
    output = []
    nums = nums.tolist()
    for n in nums:
        fx = h(x,n, gamma)
        fy = stat.gumbeldf(n, alphaPrice, betaPrice)
        output.append(fx * fy / k)
    return np.array(output)

# def Phi(nums, x):
#     sum = 0
#     output = []
#     tempNums = []
#     for n in nums.tolist():
#         tempNums.append(n)
#         tempNums = np.array(tempNums)
#         phiTemp = phi(tempNums, x)
#         phiTemp = phiTemp.tolist()[-1]
#         tempNums = tempNums.tolist()
#         sum += phiTemp * 0.01
#         output.append(sum)
#     return np.array(output)

def Phi(nums, x):
    outputList = []
    sum = 0
    k = kx(x, nums)
    for n in nums.tolist():
        fx = h(x, n, gamma)
        fy = stat.gumbeldf(n, alphaPrice, betaPrice)
        phi = fx * fy / k
        sum += phi * 0.01
        outputList.append(sum)
    return np.array(outputList)

xs = np.arange(0.01, .40, 0.001)

def quantileFunction(xs, p):
    outputList = []
    for x in xs.tolist():
        computedYs = Phi(nums, x).tolist()
        ys = nums.tolist()
        for i in range(len(ys)):
            if computedYs[i] > p:
                outputList.append(ys[i])
                break
    return np.array(outputList)

quant50 = quantileFunction(xs, 0.5)
quant25 = quantileFunction(xs, 0.25)
quant75 = quantileFunction(xs, 0.75)
quant10 = quantileFunction(xs, 0.1)
quant90 = quantileFunction(xs, 0.9)
plt.scatter(x = xs, y = quant50, color = 'gray', s = 10, label = 'Median Posterior Probability')
plt.scatter(x = xs, y = quant25, color = 'darkgray', s = 10, label = '50% Credible Confidence Interval')
plt.scatter(x = xs, y = quant75, color = 'darkgray', s = 10)
plt.scatter(x = xs, y = quant10, color = 'lightgray', s = 10, label = '90% Credible Confidence Interval')
plt.scatter(x = xs, y = quant90, color = 'lightgray', s = 10)
plt.legend()
plt.title("Quantile Functions for Credible Confidence Intervals")
plt.xlabel("Percent Solar and Wind")
plt.ylabel('Price of Electricity')
plt.savefig(stat.getDownloadsTab() + '/Quantile Functions.png')



# dist10 = Phi(nums, 10)
# dist30 = Phi(nums, 30)
# dist = stat.gumbelDF(nums, alphaPrice, betaPrice)
# plt.scatter(x = nums, y = dist, color = 'gray', s = 10, label = 'Prior Distribution Function')
# plt.scatter(x = nums, y = dist10, color = 'darkgray', s = 10, label = 'Conditioned on Percent = 10')
# plt.scatter(x = nums, y = dist30, color = 'lightgray', s = 10, label = 'Conditioned on Percent = 30')
# plt.legend()
# plt.title('Posterior Distribution Functions')
# plt.xlabel('Price of Electricity')
# plt.ylabel('Cumulative Probability Density')
# plt.savefig(stat.getDownloadsTab() + '/Posterior distribution.png')



# priceCond10 = priceCond(nums, 10)
# priceCond30 = priceCond(nums, 30)
# plt.scatter(x = nums, y = priorPrice, color = 'gray', label = 'Prior Probability', s = 10)
# plt.scatter(x = nums, y = priceCond10, color = 'lightgray', label = 'Conditioned on Percent = 10', s= 10)
# plt.scatter(x = nums, y = priceCond30, color = 'darkgray', label = 'Conditioned on Percent = 30', s = 10)
# plt.legend()
# plt.title("Comparing prior probability density with posterior probability density")
# plt.xlabel('Price of electricity')
# plt.ylabel('Probability density')
# plt.savefig(stat.getDownloadsTab() + '/Posterior comparison probability.png')
